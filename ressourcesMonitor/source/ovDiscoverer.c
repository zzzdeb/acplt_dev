
/******************************************************************************
*
*   FILE
*   ----
*   ovDiscoverer.c
*
*   History
*   -------
*   2018-07-20   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_ressourcesMonitor
#define OV_COMPILE_LIBRARY_ressourcesMonitor
#endif


#include "ressourcesMonitor.h"
#include "libov/ov_macros.h"
#include "libov/ov_vendortree.h"

#include <dns_sd.h>
#include <unistd.h>
#if OV_SYSTEM_NT
#define HOST_NAME_MAX 255
#include <windows.h>
#include <ws2tcpip.h>
#else
#include <limits.h>
#include <arpa/inet.h>
#include <ifaddrs.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/select.h>
#endif

#define LOOKUP_IP_ADDRESS FALSE
#define INCLUDE_OWN_SERVER FALSE


/**
 * Add a discovered ov server to the vector of servers.
 *
 * This function extracts the OV servername from the given DNS fullname, looks up the IP of the discovered hostname,
 * resizes the server list and adds the data in the correct format.
 *
 * @param list The string vector (server list) to add the entry to
 * @param fullname The DNS fullname of the discovered server
 * @param interfaceIndex The interfaceIndex (according to mDNS service)
 * @param hostname The hostname where the OV server is located (as resolved via mDNS)
 * @param port The port of the OV instance (in host byte order!)
 */
static void addServerToList(OV_STRING_VEC *list, const char *fullname, uint32_t interfaceIndex, const char *hostname,
		uint16_t port) {
	// Search list for identical entry and skip in this case
	char searchVal[kDNSServiceMaxDomainName + 2 + 10];
	int searchLen = snprintf(searchVal, kDNSServiceMaxDomainName + 2 + 10, "%s\t%u\t", fullname, interfaceIndex);
	for (size_t i = 0; i < list->veclen; ++i) {
		if (strncmp(list->value[i], searchVal, searchLen) == 0) {
			return;
		}
	}

	// Extract OV server name from DNS fullname
	char servername[OV_NAME_MAXLEN+1] = "";
	char *delim = strstr(fullname, "\\.");
	if (delim) {
		strncpy(servername, fullname, delim-fullname);
	}

#if !INCLUDE_OWN_SERVER
	// Get local hostname and OV servername
	char ourHostname[HOST_NAME_MAX];
	OV_ANY ourServername;
	ov_vendortree_getservername(&ourServername, NULL);
	gethostname(ourHostname, HOST_NAME_MAX);

	// Extract simple hostname from DNS fullname and compare hostname and OV servername to our data
	char *delim2 = strstr(delim+2, ".");
	if (strncmp(delim+2, ourHostname, delim2-delim-2) == 0
			&& strcmp(servername, ourServername.value.valueunion.val_string) == 0) {
		ov_logfile_info("Skipping that server (%s), b/c it seems to be ourselves.", fullname);
		return;
	}
#endif

#if LOOKUP_IP_ADDRESS
	// Lookup IP of OV server's host
	// TODO replace by DNSServiceGetAddrInfo on Windows (with Bonjour)
	// This requires _POSIX_C_SOURCE=200112L
	// It also requires in most cases, that <hostname>.local hostnames can be resolved properly. This may require the
	// system's DNS to be configured for resolution via mDNS.
	struct addrinfo *addr;
	char addr_str[INET6_ADDRSTRLEN] = "";
	int res = getaddrinfo(hostname, NULL, NULL, &addr);
	if (res == 0) {
		// convert IP to string
		res = getnameinfo(addr->ai_addr, sizeof(struct addrinfo), addr_str, INET6_ADDRSTRLEN, NULL,
				0, NI_NUMERICHOST);
		freeaddrinfo(addr);
	} else {
		ov_logfile_warning("Could not resolve IP address of OV server host %s: %s", hostname, gai_strerror(res));
	}
#endif

	// Resize string vector and add entry as tab separated string: fullname, interfaceIndex, ip, port, servername
	Ov_SetDynamicVectorLength(list, list->veclen+1, STRING);
	ov_string_print(&list->value[list->veclen-1], "%s\t%u\t%s\t%hu\t%s",
			fullname,
			interfaceIndex,
#if LOOKUP_IP_ADDRESS
			addr_str[0] ? addr_str : hostname,
#else
			hostname,
#endif
			port,
			servername);
}

/**
 * Remove an OV server from the list of discovered servers.
 *
 * @param list The string vector (server list) to remove the entry from
 * @param fullname The DNS fullname of the discovered server (without trailing dot)
 * @param interfaceIndex The interfaceIndex (according to mDNS service)
 */
static void removeServerFromList(OV_STRING_VEC *list, const char *fullname, uint32_t interfaceIndex) {
	// Build search string
	char searchVal[kDNSServiceMaxDomainName + 2 + 10];
	int searchLen = snprintf(searchVal, kDNSServiceMaxDomainName + 2 + 10, "%s.\t%u\t", fullname, interfaceIndex);

	// Swap all strings matching the given search string to the end of the string vector
	unsigned int newIndex = 0, oldIndex = 0;
	while(oldIndex < list->veclen) {
		if (strncmp(list->value[oldIndex], searchVal, searchLen) != 0) {
			// Entry should be kept. If neccessary, swap it to a new place
			if (oldIndex != newIndex){
				// Swap strings
				OV_STRING tmp = list->value[oldIndex];
				list->value[oldIndex] = list->value[newIndex];
				list->value[newIndex] = tmp;
			}
			++newIndex;
		}
		++oldIndex;
	}

	// shorten list to length of new index. This will automatically free all deleted strings (which we swapped into
	// the range behind newIndex)
	Ov_SetDynamicVectorLength(list, newIndex, STRING);
}


static void DNSServiceResolveCallback(
		DNSServiceRef                       sdRef,
		DNSServiceFlags                     flags,
		uint32_t                            interfaceIndex,
		DNSServiceErrorType                 errorCode,
		const char                          *fullname,
		const char                          *hosttarget,
		uint16_t                            port,
		uint16_t                            txtLen,
		const unsigned char                 *txtRecord,
		void                                *context)
{
	resolveContext *pContext = (resolveContext*) context;

	ov_logfile_info("New OV server discovered: %s at %s:%hu (via Iface %u)", fullname, hosttarget, ntohs(port),
			interfaceIndex);

	if (fullname == NULL) {
		ov_logfile_error("Skipping Server with fullname (null).");
	} else {
		// Add entry to list
		addServerToList(&Ov_DynamicPtrCast(ressourcesMonitor_ovDiscoverer, pContext->pinst)->v_ovServers,
				fullname, interfaceIndex, hosttarget, ntohs(port));
	}

	// Set terminate flag to let resolveContext be terminated by update loop
	pContext->terminate = TRUE;
}


static void DNSServiceBrowseCallback(
	DNSServiceRef                       sdRef,
	DNSServiceFlags                     flags,
	uint32_t                            interfaceIndex,
	DNSServiceErrorType                 errorCode,
	const char                          *serviceName,
	const char                          *regtype,
	const char                          *replyDomain,
	void                                *context)
{
	ov_logfile_debug("DNSServiceBrowseCallback has been called with error code %i for service %s.%s%s", errorCode,
			serviceName, regtype, replyDomain);

	if (errorCode != kDNSServiceErr_NoError)
		return;

	OV_INSTPTR_ressourcesMonitor_ovDiscoverer pinst = (OV_INSTPTR_ressourcesMonitor_ovDiscoverer)context;
	char fullname[kDNSServiceMaxDomainName];
	DNSServiceConstructFullName(fullname, serviceName, regtype, replyDomain);

	// Function is called due to a new server
	if (flags & kDNSServiceFlagsAdd) {
		// Create resolveContext to be passed to the response Callback
		resolveContext *pContext = (resolveContext*) malloc(sizeof(resolveContext));
		pContext->pinst = Ov_PtrUpCast(ov_object, pinst);
		pContext->terminate = FALSE;
		pContext->next = NULL;
		// Prepend resloveContext to linked list to get sdRef's socket checked for updates
		pContext->next = pinst->v_resolveContexts;
		pinst->v_resolveContexts = pContext;

		DNSServiceErrorType res = DNSServiceResolve(&pContext->sdRef, 0, interfaceIndex, serviceName, regtype,
				replyDomain, &DNSServiceResolveCallback, pContext);
		if (res != kDNSServiceErr_NoError) {
			ov_logfile_error("Could not resolve service %s. DNSServiceResolve returned error code %i", fullname, res);
		}
	} else {
		ov_logfile_info("Lost connection to OV Server %s (via Iface %u)", fullname, interfaceIndex);
		removeServerFromList(&pinst->v_ovServers, fullname, interfaceIndex);
	}
}


static OV_RESULT startBrowsingServers(OV_INSTPTR_ressourcesMonitor_ovDiscoverer pinst) {
	DNSServiceErrorType res = DNSServiceBrowse(&pinst->v_sdRef, 0, 0, "_ov._tcp", NULL, &DNSServiceBrowseCallback,
			pinst);
	if (res == kDNSServiceErr_NoError) {
		pinst->v_isDiscovering = TRUE;
		return OV_ERR_OK;
	} else {
		ov_logfile_error("Could not start network discovery: Errorcode %i", res);
		return OV_ERR_GENERIC;
	}
}


/**
 * Uninlined code to stop the mDNS based browsing for OV servers.
 *
 * This function deallocates the sdRef used for DNSServiceBrowse and all open sdRefs used for DNSServiceBrowseCallback.
 * It also clears the list of discovered servers.
 *
 * @param pinst The ovDiscoverer instance to clear its ressources
 */
static void stopBrowsingServers(OV_INSTPTR_ressourcesMonitor_ovDiscoverer pinst) {
	// Deallocate socket to mDNS daemon
	DNSServiceRefDeallocate(pinst->v_sdRef);
	pinst->v_isDiscovering = FALSE;
	// Deallocate sockets for DNSReslove calls
	resolveContext* resContext = pinst->v_resolveContexts;
	while (resContext) {
		resolveContext* next = resContext->next;
		DNSServiceRefDeallocate(resContext->sdRef);
		free(resContext);
		resContext = next;
	}
	pinst->v_resolveContexts = NULL;
	// Delete discovered servers from list
	Ov_SetDynamicVectorLength(&pinst->v_ovServers, 0, STRING);
}


OV_DLLFNCEXPORT void ressourcesMonitor_ovDiscoverer_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_ressourcesMonitor_ovDiscoverer pinst = Ov_StaticPtrCast(ressourcesMonitor_ovDiscoverer, pfb);

    if (pinst->v_discover && !pinst->v_isDiscovering) {
    	startBrowsingServers(pinst);
    } else
    if (pinst->v_isDiscovering) {
    	if (pinst->v_discover) {
    		// Check socket for new data from mDNS daemon
    		int sock = DNSServiceRefSockFD(pinst->v_sdRef);
    	    struct timeval tv;
    	    tv.tv_sec = 0;
    	    tv.tv_usec = 10000;
    		fd_set sockset;
    		FD_ZERO(&sockset);
    		FD_SET(sock, &sockset);
    		if (select(sock + 1, &sockset, NULL, NULL, &tv) > 0 && FD_ISSET(sock, &sockset)) {
    			DNSServiceProcessResult(pinst->v_sdRef);
    		}

    		// Check sockets of DNSServiceResolve calls for new data from mDNS daemon or planned deletion
    		resolveContext *resContext = pinst->v_resolveContexts;
    		resolveContext *previous = NULL;
    		while (resContext) {
    			resolveContext *next = resContext->next;
    			// Deconstruct and delete the reslolveContext if it is set for termination (and close the gap in the linked list)
    			if (resContext->terminate) {
    				DNSServiceRefDeallocate(resContext->sdRef);
    				free(resContext);
    				if (previous)
    					previous->next = next;
					else
						pinst->v_resolveContexts = next;

    			// Else check it for updates
    			} else {
					sock = DNSServiceRefSockFD(resContext->sdRef);
					FD_SET(sock, &sockset);
					if (select(sock + 1, &sockset, NULL, NULL, &tv) > 0 && FD_ISSET(sock, &sockset)) {
						DNSServiceProcessResult(resContext->sdRef);
					}
	    			previous = resContext;
    			}

				resContext = next;
    		}

    	} else {
			stopBrowsingServers(pinst);
    	}
    }
}


OV_DLLFNCEXPORT void ressourcesMonitor_ovDiscoverer_shutdown(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_ressourcesMonitor_ovDiscoverer pinst = Ov_StaticPtrCast(ressourcesMonitor_ovDiscoverer, pobj);

    stopBrowsingServers(pinst);

    /* set the object's state to "shut down" */
    fb_functionblock_shutdown(pobj);

    return;
}

