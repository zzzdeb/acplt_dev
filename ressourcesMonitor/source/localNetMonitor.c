
/******************************************************************************
*
*   FILE
*   ----
*   localNetMonitor.c
*
*   History
*   -------
*   2018-06-08   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_ressourcesMonitor
#define OV_COMPILE_LIBRARY_ressourcesMonitor
#endif


#include "ressourcesMonitor.h"
#include "libov/ov_macros.h"

#if OV_SYSTEM_LINUX
#define NI_MAXHOST  1025
#include <sys/types.h>
#include <ifaddrs.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#endif

#if OV_SYSTEM_NT
#include <windows.h>
#include <iphlpapi.h>
#include <ws2tcpip.h>
#endif


/**
 * Check if an IPv4 address lies inside a specified network range
 *
 * Source: https://stackoverflow.com/a/25290862
 *
 * @param addr The IPv4 address to check
 * @param net  The IPv4 address of the network
 * @param mask The Netmask as CIDR-bits
 * @return TRUE if the given IPv4 address is in the network specified by net and mask
 */
static OV_BOOL cidr_match(const struct in_addr *addr, const struct in_addr *net, uint8_t mask) {
  if (mask == 0) {
    // C99 6.5.7 (3): u32 << 32 is undefined behaviour
    return TRUE;
  }
  return !((addr->s_addr ^ net->s_addr) & htonl(0xFFFFFFFFu << (32 - mask)));
}

/**
 * Check if an IPv6 address lies inside a specified network range
 *
 * Source: https://stackoverflow.com/a/25290862
 *
 * @param addr The IPv6 address to check
 * @param net  The IPv6 address of the network
 * @param mask The Netmask as CIDR-bits
 * @return TRUE if the given IPv6 address is in the network specified by net and mask
 */
static OV_BOOL cidr6_match(const struct in6_addr *addr, const struct in6_addr *net, uint8_t mask) {
#if OV_SYSTEM_LINUX
  const uint32_t *a = addr->__in6_u.__u6_addr32;
  const uint32_t *n = net->__in6_u.__u6_addr32;
#else
  const uint32_t *a = (uint32_t*)addr->_S6_un._S6_u32;
  const uint32_t *n = (uint32_t*)net->_S6_un._S6_u32;
#endif

  int bits_whole, bits_incomplete;
  bits_whole = mask >> 5;         // number of whole u32
  bits_incomplete = mask & 0x1F;  // number of bits in incomplete u32
  if (bits_whole) {
    if (memcmp(a, n, bits_whole << 2)) {
      return FALSE;
    }
  }
  if (bits_incomplete) {
    if ((a[bits_whole] ^ n[bits_whole]) & htonl((0xFFFFFFFFu) << (32 - bits_incomplete))) {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Check a sockaddr if it is a valid connection to an IPv4 or IPv6 network.
 *
 * Checks if the given socket address pointer is NULL, is of address family INET or INET6 and does not contain a local
 * or link-local address.
 *
 * @param addr Pointer to the sock addr to check
 * @return TRUE if the address specifies a valid network connection
 */
OV_BOOL is_valid_address(const struct sockaddr *addr) {
	/* Local subnets for ipv4:
	 * 0.0.0.0/8
	 * 127.0.0.0/8
	 * 169.254.0.0/16
	 * 224.0.0.0/4
	 * (See https://tools.ietf.org/html/rfc5735#section-4 for details)
	 */
	#define IP4_LOCAL_NUM 4

#if OV_SYSTEM_LINUX
	const struct in_addr ip4_local[IP4_LOCAL_NUM]         = {{0}, {htonl(127<<24)}, {htonl((172<<24) + (16<<16))}, {htonl(224<<24)}};
#else
	const struct in_addr ip4_local[IP4_LOCAL_NUM]         = {
			{{.S_addr = 0}},
			{{.S_addr = htonl(127<<24)}},
			{{.S_addr = htonl(224<<24)}},
			{{.S_addr = htonl((172<<24) + (16<<16))}}};
#endif
	const uint8_t ip4_local_masks[IP4_LOCAL_NUM] = {8, 8, 16, 4};

	/* Local subnets for ipv6:
	 * ::/128
	 * ::1/128
	 * fc00::/7
	 * fe80::/10
	 * ff00::/8
	 * (See https://tools.ietf.org/html/rfc6890#section-2.2.3 for details)
	 */
	#define IP6_LOCAL_NUM 5
	// Attention: little endian byte order in in6_addr
#if OV_SYSTEM_LINUX
	const struct in6_addr ip6_local[IP6_LOCAL_NUM] = {
			{ { .__u6_addr32 = { 0, 0, 0, 0 } } },
			{ { .__u6_addr32 = { 0, 0, 0, htonl(1) } } },
			{ { .__u6_addr32 = { htonl(0xfc000000), 0, 0, 0 } } },
			{ { .__u6_addr32 = { htonl(0xfe800000), 0, 0, 0 } } },
			{ { .__u6_addr32 = { htonl(0xff000000), 0, 0, 0 } } }};
#else
	const struct in6_addr ip6_local[IP6_LOCAL_NUM] = {
			{ { ._S6_u32 = { 0, 0, 0, 0 } } },
			{ { ._S6_u32 = { 0, 0, 0, htonl(1) } } },
			{ { ._S6_u32 = { htonl(0xfc000000), 0, 0, 0 } } },
			{ { ._S6_u32 = { htonl(0xfe800000), 0, 0, 0 } } },
			{ { ._S6_u32 = { htonl(0xff000000), 0, 0, 0 } } }};
#endif
	const uint8_t ip6_local_masks[IP6_LOCAL_NUM] = {128, 128, 7, 10, 8};

	if (addr == NULL)
		return FALSE;

	if (addr->sa_family != AF_INET && addr->sa_family != AF_INET6)
		return FALSE;

	if (addr->sa_family == AF_INET) {
		for (int i=0; i < IP4_LOCAL_NUM; ++i) {
			if (cidr_match(&((struct sockaddr_in*)addr)->sin_addr, &ip4_local[i], ip4_local_masks[i]))
				return FALSE;
		}

	} else if (addr->sa_family == AF_INET6) {
		for (int i=0; i < IP6_LOCAL_NUM; ++i) {
			if (cidr6_match(&((struct sockaddr_in6*)addr)->sin6_addr, &ip6_local[i], ip6_local_masks[i]))
				return FALSE;
		}
	}

	return TRUE;
}


OV_DLLFNCEXPORT void ressourcesMonitor_localNetMonitor_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
    OV_INSTPTR_ressourcesMonitor_localNetMonitor pinst = Ov_StaticPtrCast(ressourcesMonitor_localNetMonitor, pfb);


#if OV_SYSTEM_LINUX
    // Some data structures
    struct ifaddrs *ifaddr, *ifa;

	// Let the kernel create the ifaddrs data and give us a pointer; quit on failure
	if (getifaddrs(&ifaddr) == -1) {
		return;
	}

	// Iterate linked ifaddrs list once, to resize string vector to number of ipaddresses
	OV_UINT num_ips = 0;
	for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
		if (!is_valid_address(ifa->ifa_addr))
			continue;
		++num_ips;
	}
	Ov_SetDynamicVectorLength(&pinst->v_localNetworks, num_ips, STRING);

	// Iterate list again to fill vector
	num_ips = 0;
	for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
		if (!is_valid_address(ifa->ifa_addr))
			continue;

		if (ifa->ifa_addr->sa_family == AF_INET) {
			// Get unique address of ipv4 subnet by bitwise AND-ing netmask with address
			struct in_addr subnet;
			subnet.s_addr = ((struct sockaddr_in*)(ifa->ifa_addr))->sin_addr.s_addr &
					((struct sockaddr_in*)(ifa->ifa_netmask))->sin_addr.s_addr;

			// Get decimal representation of subnet's address
			char addr[INET_ADDRSTRLEN];
			const char *res = inet_ntop(AF_INET, &subnet, addr, INET_ADDRSTRLEN);
			ov_string_setvalue(&pinst->v_localNetworks.value[num_ips], "ip4://");
			if (res) {
				ov_string_append(&pinst->v_localNetworks.value[num_ips], addr);
			}
			// TODO add cidr netmask suffix?

		} else if (ifa->ifa_addr->sa_family == AF_INET6) {
			// Get unique address of ipv6 subnet by bitwise AND-ing netmask with address
			struct in6_addr subnet;
			for(int i=0; i < 4; ++i) {
				subnet.__in6_u.__u6_addr32[i] = ((struct sockaddr_in6*)(ifa->ifa_addr))->sin6_addr.__in6_u.__u6_addr32[i] &
						((struct sockaddr_in6*)(ifa->ifa_netmask))->sin6_addr.__in6_u.__u6_addr32[i];
			}

			// Get hex representation of subnet's address
			char addr[INET6_ADDRSTRLEN];
			const char *res = inet_ntop(AF_INET6, &subnet, addr, INET6_ADDRSTRLEN);
			ov_string_setvalue(&pinst->v_localNetworks.value[num_ips], "ip6://");
			if (res) {
				ov_string_append(&pinst->v_localNetworks.value[num_ips], addr);
			}
		}
		++num_ips;
	}

	// Free ifaddrs data
    freeifaddrs(ifaddr);

#elif OV_SYSTEM_NT && WINVER >= 0x0501
    // Code from https://msdn.microsoft.com/de-de/library/windows/desktop/aa365915(v=vs.85).aspx

    // Try to get AdapterAddresses until allocated memory is sufficient
    // Start with 15k
    unsigned long outBufLen = 15000;
    unsigned long dwRetVal = NULL;
    unsigned int iterations = 0;
    IP_ADAPTER_ADDRESSES *pAddresses;
	do {
		++iterations;
		pAddresses = (IP_ADAPTER_ADDRESSES *) malloc(outBufLen);
		if (pAddresses == NULL) {
			// Allocating memory failed
			return;
		}

		dwRetVal = GetAdaptersAddresses(AF_UNSPEC, GAA_FLAG_INCLUDE_PREFIX, NULL, pAddresses, &outBufLen);

		if (dwRetVal == ERROR_BUFFER_OVERFLOW) {
			free(pAddresses);
			pAddresses = NULL;
		} else {
			break;
		}
	} while (iterations < 5);
	if (pAddresses == NULL)
		// Getting IP addresses failed
		return;

	// Iterate linked pAddresses list once, to resize string vector to number of ipaddresses
	IP_ADAPTER_ADDRESSES *pCurrAddresses;
	OV_UINT num_ips = 0;
	for (pCurrAddresses = pAddresses; pCurrAddresses; pCurrAddresses = pCurrAddresses->Next) {
		IP_ADAPTER_PREFIX *pPrefix;
		for (pPrefix = pCurrAddresses->FirstPrefix; pPrefix; pPrefix = pPrefix->Next) {
			if (!is_valid_address(pPrefix->Address.lpSockaddr))
				continue;
			if ((pPrefix->Address.lpSockaddr->sa_family == AF_INET && pPrefix->PrefixLength == 32)
					|| pPrefix->PrefixLength == 128)
				continue;
			++num_ips;
		}
	}
	Ov_SetDynamicVectorLength(&pinst->v_localNetworks, num_ips, STRING);

	// Iterate list again to fill vector
	num_ips = 0;
	for (pCurrAddresses = pAddresses; pCurrAddresses; pCurrAddresses = pCurrAddresses->Next) {
		IP_ADAPTER_PREFIX *pPrefix;
		for (pPrefix = pCurrAddresses->FirstPrefix; pPrefix; pPrefix = pPrefix->Next) {
			if (!is_valid_address(pPrefix->Address.lpSockaddr))
				continue;
			if ((pPrefix->Address.lpSockaddr->sa_family == AF_INET && pPrefix->PrefixLength == 32)
					|| pPrefix->PrefixLength == 128)
				continue;

			if (pPrefix->Address.lpSockaddr->sa_family == AF_INET) {
				// Get decimal representation of subnet's address
				char *addr = inet_ntoa(((struct sockaddr_in*)(pPrefix->Address.lpSockaddr))->sin_addr);
				ov_string_setvalue(&pinst->v_localNetworks.value[num_ips], "ip4://");
				if (addr)
					ov_string_append(&pinst->v_localNetworks.value[num_ips], addr);
				// TODO add cidr netmask suffix?

			} else if (pPrefix->Address.lpSockaddr->sa_family == AF_INET6) {
				// Get decimal representation of subnet's address
				char addr[INET6_ADDRSTRLEN+4];
				int res = getnameinfo(pPrefix->Address.lpSockaddr, sizeof(SOCKADDR_IN6), addr, INET6_ADDRSTRLEN+4, NULL,
						0, NI_NUMERICHOST);
				ov_string_setvalue(&pinst->v_localNetworks.value[num_ips], "ip6://");
				if (res == 0) {
					// cut the NetMask returned by getnameinfo
					for (int i=0; i<INET6_ADDRSTRLEN+4; ++i) {
						if (addr[i] == '%') {
							addr[i] = '\0';
							break;
						} else if (addr[i] == '\0') {
							break;
						}
					}
					ov_string_append(&pinst->v_localNetworks.value[num_ips], addr);
				}
				// TODO add cidr netmask suffix?
			}

			++num_ips;
		}
	}

	free(pAddresses);
#endif
}

