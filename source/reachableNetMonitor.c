
/******************************************************************************
*
*   FILE
*   ----
*   reachableNetMonitor.c
*
*   History
*   -------
*   2018-08-11   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_ressourcesMonitor
#define OV_COMPILE_LIBRARY_ressourcesMonitor
#endif


#include "ressourcesMonitor.h"
#include "libov/ov_macros.h"
#include "libov/ov_database.h"
#include "libov/ov_path.h"

#if OV_SYSTEM_NT
#include <windows.h>
#else
#include <arpa/inet.h>
#endif

#define STR_IMPL_(x) #x      //stringify argument
#define STR(x) STR_IMPL_(x)  //indirection to expand argument macros

/**
 * Allocate a new networkEntry and prepend it to the given networkList.
 *
 * @param list		Pointer to the networkList to prepend the new entry to
 * @param networkId	The network identifer string
 * @param hops		The number of hops to reach the network
 * @param nextHop	The address of the next hop to reach the network
 * @param routable	If traffic to the network can be routed through this node
 * @return			The operations result. May be OV_ERR_DBOUTOFMEMORY.
 */
static OV_RESULT addNetworkToList(networkList *list, OV_STRING networkId, OV_UINT hops, OV_STRING nextHop, OV_BOOL routable) {
	networkEntry *newEntry = ov_database_malloc(sizeof(networkEntry));
	if (!newEntry) {
		return OV_ERR_DBOUTOFMEMORY;
	}
	ov_string_setvalue(&newEntry->networkId, networkId);
	newEntry->hops = hops;
	ov_string_setvalue(&newEntry->nextHop, nextHop);
	newEntry->routable = routable;
	newEntry->next = list->first;

	list->first = newEntry;
	++list->num;
	return OV_ERR_OK;
}

/**
 * Clear a given networkList, while taking care of all the allocated memory. (Frees referenced OV_STRINGs and the
 * networkEntrys).
 *
 * @param list		Pointer to the networkList to be cleared
 */
static void clearNetworkList(networkList *list) {
	networkEntry *pEntry = list->first;
	while (pEntry) {
		networkEntry *next = pEntry->next;
		ov_string_setvalue(&pEntry->networkId, NULL);
		ov_string_setvalue(&pEntry->nextHop, NULL);
		ov_database_free(pEntry);
		pEntry = next;
	}
	list->num = 0;
}

/**
 * Add a networkEntry to the given networkList, if the network is unknown, or update the existing entry for this network
 * identifier, if a new route with less itermediate hops has been found.
 *
 * @param list		Pointer to the networkList to prepend the new entry to
 * @param networkId	The network identifer string
 * @param hops		The number of hops to reach the network
 * @param nextHop	The address of the next hop to reach the network
 * @param routable	If traffic to the network can be routed through this node
 * @return			The operations result. May be OV_ERR_DBOUTOFMEMORY.
 */
static OV_RESULT addNetworkIfBetter(networkList *list, OV_STRING networkId, OV_UINT hops, OV_STRING nextHop, OV_BOOL routable) {
	networkEntry *pEntry = list->first;
	while (pEntry) {
		if (ov_string_compare(pEntry->networkId, networkId) == OV_STRCMP_EQUAL) {
			if (hops < pEntry->hops) {
				pEntry->hops = hops;
				ov_string_setvalue(&pEntry->nextHop, nextHop);
				pEntry->routable = routable;
			}
			return OV_ERR_OK;
		}
		pEntry = pEntry->next;
	}
	return addNetworkToList(list, networkId, hops, nextHop, routable);
}


/**
 * Send a getVar query to the next server in the internal list of servers.
 *
 * @param pinst The reachableNetMonitor instance to work upon
 * @return The result of the operation
 */
static OV_RESULT sendQueryToServer(OV_INSTPTR_ressourcesMonitor_reachableNetMonitor pinst) {
	// Reset apiGet object
	ksapi_KSApiCommon_Reset_set(Ov_PtrUpCast(ksapi_KSApiCommon, &pinst->p_apiGet), FALSE);
	ksapi_KSApiCommon_Reset_set(Ov_PtrUpCast(ksapi_KSApiCommon, &pinst->p_apiGet), TRUE);

	// Parse active server from the list
	char host[INET6_ADDRSTRLEN+1];
	OV_UINT port;
	char server[OV_NAME_MAXLEN+1];
	sscanf(pinst->v_ovServersInt.value[pinst->v_nextQueryServer], "%*[^\t]\t%*[^\t]\t%" STR(INET6_ADDRSTRLEN) "[^\t]\t%u\t%" STR(OV_NAME_MAXLEN) "[^\t]",
			host, &port, server);

	// Gather data and send request
	ov_string_setvalue(&pinst->p_apiGet.v_serverHost, host);
	ov_string_setvalue(&pinst->p_apiGet.v_serverName, server);
	ov_string_setvalue(&pinst->p_apiGet.v_path, ov_path_getcanonicalpath(Ov_PtrUpCast(ov_object, pinst), 2));
	ov_string_append(&pinst->p_apiGet.v_path, ".networks");
	//pinst->v_startts = *pltc; // TODO
	ksapi_KSApiCommon_Submit_set(Ov_PtrUpCast(ksapi_KSApiCommon, &pinst->p_apiGet), FALSE);
	ksapi_KSApiCommon_Submit_set(Ov_PtrUpCast(ksapi_KSApiCommon, &pinst->p_apiGet), TRUE);

	return OV_ERR_OK;
}


OV_DLLFNCEXPORT void ressourcesMonitor_reachableNetMonitor_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_ressourcesMonitor_reachableNetMonitor pinst = Ov_StaticPtrCast(ressourcesMonitor_reachableNetMonitor, pfb);

	// TODO if not querySent
    	// TODO  if time since last update > ~ 30 sec)
			// TODO add local networks to networkList
			// TODO copy ov server list to internal variable
			// TODO set active server index to 0
    		// TODO sendQueryToServer(pinst);
    		// TODO set querySent = TRUE

    // TODO if querySent
		// TODO check if value was returned (or timeout?)
			// TODO if value is okay
				// TODO for each network in list
				// TODO parse entry
				// TODO use addNetworkIfBetter
			// TODO set active server to next server
			// TODO if active server >= server list size
				// TODO generate output string list from internal linked list
				// TODO clear linked list
				// TODO update last update timestamp set querySent = FALSE
			// TODO else
				// TODO sendQueryToServer(pinst);

    return;
}
