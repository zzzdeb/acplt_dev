
/******************************************************************************
*
*   FILE
*   ----
*   localNetMonitor.c
*
*   History
*   -------
*   2018-06-08   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_ressourcesMonitor
#define OV_COMPILE_LIBRARY_ressourcesMonitor
#endif


#include "ressourcesMonitor.h"
#include "libov/ov_macros.h"

#if OV_SYSTEM_LINUX
#define NI_MAXHOST  1025
#include <sys/types.h>
#include <ifaddrs.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#endif


/**
 * Check if an IPv4 address lies inside a specified network range
 *
 * Source: https://stackoverflow.com/a/25290862
 *
 * @param addr The IPv4 address to check
 * @param net  The IPv4 address of the network
 * @param mask The Netmask as CIDR-bits
 * @return TRUE if the given IPv4 address is in the network specified by net and mask
 */
static OV_BOOL cidr_match(const struct in_addr *addr, const struct in_addr *net, uint8_t mask) {
  if (mask == 0) {
    // C99 6.5.7 (3): u32 << 32 is undefined behaviour
    return TRUE;
  }
  return !((addr->s_addr ^ net->s_addr) & htonl(0xFFFFFFFFu << (32 - mask)));
}

/**
 * Check if an IPv6 address lies inside a specified network range
 *
 * Source: https://stackoverflow.com/a/25290862
 *
 * @param addr The IPv6 address to check
 * @param net  The IPv6 address of the network
 * @param mask The Netmask as CIDR-bits
 * @return TRUE if the given IPv6 address is in the network specified by net and mask
 */
static OV_BOOL cidr6_match(const struct in6_addr *addr, const struct in6_addr *net, uint8_t mask) {
  const uint32_t *a = addr->__in6_u.__u6_addr32;
  const uint32_t *n = net->__in6_u.__u6_addr32;
  int bits_whole, bits_incomplete;
  bits_whole = mask >> 5;         // number of whole u32
  bits_incomplete = mask & 0x1F;  // number of bits in incomplete u32
  if (bits_whole) {
    if (memcmp(a, n, bits_whole << 2)) {
      return FALSE;
    }
  }
  if (bits_incomplete) {
    if ((a[bits_whole] ^ n[bits_whole]) & htonl((0xFFFFFFFFu) << (32 - bits_incomplete))) {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Check a sockaddr if it is a valid connection to an IPv4 or IPv6 network.
 *
 * Checks if the given socket address pointer is NULL, is of address family INET or INET6 and does not contain a local
 * or link-local address.
 *
 * @param addr Pointer to the sock addr to check
 * @return TRUE if the address specifies a valid network connection
 */
OV_BOOL is_valid_address(const struct sockaddr *addr) {
	/* Local subnets for ipv4:
	 * 0.0.0.0/8
	 * 127.0.0.0/8
	 * 169.254.0.0/16
	 * (See https://tools.ietf.org/html/rfc5735#section-4 for details)
	 */
	#define IP4_LOCAL_NUM 3
	const struct in_addr ip4_local[IP4_LOCAL_NUM]         = {{0}, {htonl(127<<24)}, {htonl((172<<24) + (16<<16))}};
	const uint8_t        ip4_local_masks[IP4_LOCAL_NUM]   = {8,   8,                16};

	/* Local subnets for ipv6:
	 * ::/128
	 * ::1/128
	 * fc00::/7
	 * fe80::/10
	 * (See https://tools.ietf.org/html/rfc6890#section-2.2.3 for details)
	 */
	#define IP6_LOCAL_NUM 4
	// Attention: little endian byte order in in6_addr
	const struct in6_addr ip6_local[IP6_LOCAL_NUM] = {
			{ { .__u6_addr32 = { 0, 0, 0, 0 } } },
			{ { .__u6_addr32 = { 0, 0, 0, htonl(1) } } },
			{ { .__u6_addr32 = { htonl(0xfc000000), 0, 0, 0 } } },
			{ { .__u6_addr32 = { htonl(0xfe800000), 0, 0, 0 } } }};
	const uint8_t ip6_local_masks[IP6_LOCAL_NUM] = {128, 128, 7, 10};

	if (addr == NULL)
		return FALSE;

	if (addr->sa_family != AF_INET && addr->sa_family != AF_INET6)
		return FALSE;

	if (addr->sa_family == AF_INET) {
		for (int i=0; i < IP4_LOCAL_NUM; ++i) {
			if (cidr_match(&((struct sockaddr_in*)addr)->sin_addr, &ip4_local[i], ip4_local_masks[i]))
				return FALSE;
		}
	} else if (addr->sa_family == AF_INET6) {
		for (int i=0; i < IP6_LOCAL_NUM; ++i) {
			if (cidr6_match(&((struct sockaddr_in6*)addr)->sin6_addr, &ip6_local[i], ip6_local_masks[i]))
				return FALSE;
		}
	}

	return TRUE;
}


OV_DLLFNCEXPORT void ressourcesMonitor_localNetMonitor_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
    OV_INSTPTR_ressourcesMonitor_localNetMonitor pinst = Ov_StaticPtrCast(ressourcesMonitor_localNetMonitor, pfb);


#if OV_SYSTEM_LINUX
    // Some data structures
    struct ifaddrs *ifaddr, *ifa;

	// Let the kernel create the ifaddrs data and give us a pointer; quit on failure
	if (getifaddrs(&ifaddr) == -1) {
		return;
	}

	// Iterate linked ifaddrs list once, to resize string vector to number of ipaddresses
	OV_UINT num_ips = 0;
	for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
		if (!is_valid_address(ifa->ifa_addr))
			continue;
		++num_ips;
	}
	Ov_SetDynamicVectorLength(&pinst->v_localNetworks, num_ips, STRING);

	// Iterate list again to fill vector
	num_ips = 0;
	for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
		if (!is_valid_address(ifa->ifa_addr))
			continue;

		if (ifa->ifa_addr->sa_family == AF_INET) {
			// Get unique address of ipv4 subnet by bitwise AND-ing netmask with address
			struct in_addr subnet;
			subnet.s_addr = ((struct sockaddr_in*)(ifa->ifa_addr))->sin_addr.s_addr &
					((struct sockaddr_in*)(ifa->ifa_netmask))->sin_addr.s_addr;

			// Get decimal representation of subnet's address
			char addr[INET_ADDRSTRLEN];
			const char *res = inet_ntop(AF_INET, &subnet, addr, INET_ADDRSTRLEN);
			ov_string_setvalue(&pinst->v_localNetworks.value[num_ips], "ip4://");
			if (res) {
				ov_string_append(&pinst->v_localNetworks.value[num_ips], addr);
			}
			// TODO add cidr netmask suffix?

		} else if (ifa->ifa_addr->sa_family == AF_INET6) {
			// Get unique address of ipv6 subnet by bitwise AND-ing netmask with address
			struct in6_addr subnet;
			for(int i=0; i < 4; ++i) {
				subnet.__in6_u.__u6_addr32[i] = ((struct sockaddr_in6*)(ifa->ifa_addr))->sin6_addr.__in6_u.__u6_addr32[i] &
						((struct sockaddr_in6*)(ifa->ifa_netmask))->sin6_addr.__in6_u.__u6_addr32[i];
			}

			// Get decimal representation of subnet's address
			char addr[INET6_ADDRSTRLEN];
			const char *res = inet_ntop(AF_INET6, &subnet, addr, INET6_ADDRSTRLEN);
			ov_string_setvalue(&pinst->v_localNetworks.value[num_ips], "ip6://");
			if (res) {
				ov_string_append(&pinst->v_localNetworks.value[num_ips], addr);
			}
			// TODO add cidr netmask suffix?
		}
		++num_ips;
	}

	// Free ifaddrs data
    freeifaddrs(ifaddr);
#endif
}

