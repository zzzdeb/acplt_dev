
/******************************************************************************
*
*   FILE
*   ----
*   ovDiscoverer.c
*
*   History
*   -------
*   2018-07-20   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_ressourcesMonitor
#define OV_COMPILE_LIBRARY_ressourcesMonitor
#endif


#include "ressourcesMonitor.h"
#include "libov/ov_macros.h"

#include <dns_sd.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <arpa/inet.h>


static void DNSServiceResolveCallback(
		DNSServiceRef                       sdRef,
		DNSServiceFlags                     flags,
		uint32_t                            interfaceIndex,
		DNSServiceErrorType                 errorCode,
		const char                          *fullname,
		const char                          *hosttarget,
		uint16_t                            port,
		uint16_t                            txtLen,
		const unsigned char                 *txtRecord,
		void                                *context)
{
	resolveContext *pContext = (resolveContext*) context;

	ov_logfile_info("New OV server discovered: %s at %s:%hu", fullname, hosttarget, ntohs(port));
	// TODO lookup IP address (gethostbyname)
	// TODO add server to list

	// Set terminate flag to let resolveContext be terminated by update loop
	pContext->terminate = TRUE;
}


static void DNSServiceBrowseCallback(
	DNSServiceRef                       sdRef,
	DNSServiceFlags                     flags,
	uint32_t                            interfaceIndex,
	DNSServiceErrorType                 errorCode,
	const char                          *serviceName,
	const char                          *regtype,
	const char                          *replyDomain,
	void                                *context)
{
	ov_logfile_debug("DNSServiceBrowseCallback has been called with error code %hi for service %s.%s%s", errorCode,
			serviceName, regtype, replyDomain);

	if (errorCode != kDNSServiceErr_NoError)
		return;

	OV_INSTPTR_ressourcesMonitor_ovDiscoverer pinst = (OV_INSTPTR_ressourcesMonitor_ovDiscoverer)context;

	// Function is called due to a new server
	if (flags & kDNSServiceFlagsAdd) {
		// Create resolveContext to be passed to the response Callback
		resolveContext *pContext = (resolveContext*) malloc(sizeof(resolveContext));
		pContext->pinst = Ov_PtrUpCast(ov_object, pinst);
		pContext->serviceName = serviceName;
		pContext->regtype = regtype;
		pContext->domain = replyDomain;
		// Prepend resloveContext to linked list to get sdRef's socket checked for updates
		pContext->next = pinst->v_resolveContexts;
		pinst->v_resolveContexts = pContext;

		DNSServiceErrorType res = DNSServiceResolve(&pContext->sdRef, 0, interfaceIndex, serviceName, regtype,
				replyDomain, &DNSServiceResolveCallback, pContext);
		if (res != kDNSServiceErr_NoError) {
			ov_logfile_error("Could not resolve service %s.%s%s. DNSServiceResolve returned error code %hi",
						serviceName, regtype, replyDomain, res);
		}
	}
	// else
		// TODO search current host list for fullname\tinterfaceIndex and delete entry
}


static OV_RESULT startBrowsingServers(OV_INSTPTR_ressourcesMonitor_ovDiscoverer pinst) {
	DNSServiceErrorType res = DNSServiceBrowse(&pinst->v_sdRef, 0, 0, "_ov._tcp", NULL, &DNSServiceBrowseCallback,
			pinst);
	if (res == kDNSServiceErr_NoError) {
		pinst->v_isDiscovering = TRUE;
		return OV_ERR_OK;
	} else {
		return OV_ERR_GENERIC;
	}
}


OV_DLLFNCEXPORT void ressourcesMonitor_ovDiscoverer_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_ressourcesMonitor_ovDiscoverer pinst = Ov_StaticPtrCast(ressourcesMonitor_ovDiscoverer, pfb);

    if (pinst->v_discover && !pinst->v_isDiscovering) {
    	startBrowsingServers(pinst);
    } else
    if (pinst->v_isDiscovering) {
    	if (pinst->v_discover) {
    		// Check socket for new data from mDNS daemon
    		int sock = DNSServiceRefSockFD(pinst->v_sdRef);
    	    struct timeval tv;
    	    tv.tv_sec = 0;
    	    tv.tv_usec = 10000;
    		fd_set sockset;
    		FD_ZERO(&sockset);
    		FD_SET(sock, &sockset);
    		if (select(sock + 1, &sockset, NULL, NULL, &tv) > 0 && FD_ISSET(sock, &sockset)) {
    			DNSServiceProcessResult(pinst->v_sdRef);
    		}

    		// Check sockets of DNSServiceResolve calls for update
    		resolveContext *resContext = pinst->v_resolveContexts;
    		resolveContext *previous = NULL;
    		while (resContext) {
    			resolveContext *next = resContext->next;
    			// Deconstruct and delete the reslolveContext if it is set for termination (and close the gap in the linked list)
    			if (resContext->terminate) {
    				DNSServiceRefDeallocate(resContext->sdRef);
    				free(resContext);
    				if (previous)
    					previous->next = next;
					else
						pinst->v_resolveContexts = next;

    			// Else check it for updates
    			} else {
					sock = DNSServiceRefSockFD(resContext->sdRef);
					FD_SET(sock, &sockset);
					if (select(sock + 1, &sockset, NULL, NULL, &tv) > 0 && FD_ISSET(sock, &sockset)) {
						DNSServiceProcessResult(resContext->sdRef);
					}
    			}

				resContext = next;
    		}

    	} else {
    		// Deallocate socket to mDNS daemon
			DNSServiceRefDeallocate(pinst->v_sdRef);
			pinst->v_isDiscovering = FALSE;
    	}
    }
}


OV_DLLFNCEXPORT void ressourcesMonitor_ovDiscoverer_shutdown(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_ressourcesMonitor_ovDiscoverer pinst = Ov_StaticPtrCast(ressourcesMonitor_ovDiscoverer, pobj);

    if (pinst->v_isDiscovering) {
		DNSServiceRefDeallocate(pinst->v_sdRef);
		pinst->v_isDiscovering = FALSE;

		resolveContext *resContext = pinst->v_resolveContexts;
		while (resContext) {
			resolveContext *next = resContext->next;
			DNSServiceRefDeallocate(resContext->sdRef);
			free(resContext);
			resContext = next;
		}
		pinst->v_resolveContexts = NULL;
	}

    /* set the object's state to "shut down" */
    fb_functionblock_shutdown(pobj);

    return;
}

