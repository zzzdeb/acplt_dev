/******************************************************************************
 *
 *   FILE
 *   ----
 *   LoadLibs.c
 *
 *   History
 *   -------
 *   2018-03-29   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/

#ifndef OV_COMPILE_LIBRARY_CTree
#define OV_COMPILE_LIBRARY_CTree
#endif

#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "CTree.h"
#include "CTree_helper.h"
#include "NoneTicketAuthenticator.h"
#include "libov/ov_debug.h"
#include "libov/ov_logfile.h"
#include "libov/ov_macros.h"
#include "libov/ov_result.h"
#include "libov/ov_string.h"
#include "object_helper.h"

#include "ksapi.h"
#include "ksbase.h"
#include "ksbase_helper.h"

enum format { OS, ARCH, LIBS, ACPLTHOME, FORMATLEN };

#define DBINFO_SYSTEM "/data/CTree/dbinfo.serversystem"
#define DBINFO_ARCH "/data/CTree/dbinfo.serversystemarch"
#define DBINFO_ADDONLIBS "/data/CTree/dbinfo.addonlibs"

OV_DLLFNCEXPORT OV_RESULT
                CTree_LoadLibs_constructor(OV_INSTPTR_ov_object pobj) {
  /*
   *   local variables
   */
  OV_INSTPTR_CTree_LoadLibs pinst = Ov_StaticPtrCast(CTree_LoadLibs, pobj);
  OV_RESULT                 result;

  /* do what the base class does first */
  result = fb_functionblock_constructor(pobj);
  if(Ov_Fail(result))
    return result;

  result |= Ov_Link(fb_tasklist, pinst, &pinst->p_sendFiles);
  pinst->p_sendFiles.v_iexreq = 1;
  pinst->p_sendFiles.v_actimode = 0;

  return result;
}

OV_DLLFNCEXPORT OV_RESULT
                CTree_LoadLibs_reset_set(OV_INSTPTR_CTree_LoadLibs pobj, const OV_BOOL value) {
  OV_RESULT                    result = OV_ERR_OK;
  OV_INSTPTR_ksbase_ClientBase pClient = NULL;
  OV_VTBLPTR_ksbase_ClientBase pVtblClient = NULL;
  //  OV_VTBLPTR_CTree_SendFiles pVtblSendfiles = NULL;
  if(value && (!pobj->v_reset)) {
    pobj->v_status = CTREE_LL_INIT;
    pobj->v_result = OV_ERR_OK;

    ov_string_setvalue(&pobj->v_targetOS, NULL);
    ov_string_setvalue(&pobj->v_OS, NULL);
    pobj->v_targetArch = 0;
    pobj->v_Arch = 0;

    Ov_SetDynamicVectorLength(&pobj->v_targetLibs, 0, STRING);
    Ov_SetDynamicVectorLength(&pobj->v_libsToSend, 0, STRING);

    Ov_ForEachChildEx(
        ov_containment, pobj, pClient,
        ksbase_ClientBase) { /*	find the object in the containment which is
                                derived from ClientBase	*/
      break;
    }

    if(pClient) {
      Ov_GetVTablePtr(ksbase_ClientBase, pVtblClient, pClient);
      if(pVtblClient) {
        result = pVtblClient->m_reset(pClient);
      }
    }

    pobj->p_sendFiles.v_reset = 0;
    CTree_SendFiles_reset_set(&pobj->p_sendFiles, 1);
  }
  pobj->v_reset = value;
  return result;
}

OV_DLLFNCEXPORT void infoRequest_callback(const OV_INSTPTR_ov_domain this,
                                          const OV_INSTPTR_ov_domain that) {
  OV_INSTPTR_CTree_LoadLibs    pinst = Ov_StaticPtrCast(CTree_LoadLibs, this);
  OV_INSTPTR_ksbase_ClientBase pClient =
      Ov_StaticPtrCast(ksbase_ClientBase, that);
  OV_VTBLPTR_ksbase_ClientBase pVtblClient = NULL;
  OV_UINT                      itemsLength = 0;
  OV_GETVAR_ITEM*              itemsVals = NULL;
  OV_RESULT                    result = 0;

  if(!this || !that) {
    ov_logfile_error("callback issued with NULL pointers. aborting.");
    return;
  }

  Ov_GetVTablePtr(ksbase_ClientBase, pVtblClient, pClient);

  if(!pVtblClient) {
    ov_logfile_error(
        "%s callback: could not determine Vtable of Client %s. aborting",
        this->v_identifier, that->v_identifier);
    pinst->v_status = CTREE_COMMON_INTERNALERROR;
    pinst->v_result = OV_ERR_BADOBJTYPE;
    return;
  }
  ov_memstack_lock();
  result = pVtblClient->m_processGetVar(
      pClient, NULL, (OV_RESULT*)&(pinst->v_result), &itemsLength, &itemsVals);
  if(Ov_Fail(result)) {
    pinst->v_status = CTREE_COMMON_INTERNALERROR;
    pinst->v_result = result;
    ov_memstack_unlock();
    return;
  }

  pinst->v_status = CTREE_LL_INFO_RECEIVED;

  ov_memstack_unlock();
  if(!itemsVals[ARCH].result)
    pinst->v_targetArch =
        itemsVals[ARCH].var_current_props.value.valueunion.val_uint;
  if(!itemsVals[OS].result)
    ov_string_setvalue(
        &pinst->v_targetOS,
        itemsVals[OS].var_current_props.value.valueunion.val_string);
  if(!itemsVals[LIBS].result) {
    Ov_SetDynamicVectorValue(
        &pinst->v_targetLibs,
        itemsVals[LIBS].var_current_props.value.valueunion.val_string_vec.value,
        itemsVals[LIBS]
            .var_current_props.value.valueunion.val_string_vec.veclen,
        STRING);
  } else {
    ov_logfile_warning("couldnt get target addonlibs: %u",
                       itemsVals[LIBS].result);
  }
  //	char sep = '/';
  //	if(!itemsVals[ACPLTHOME].result)
  //		ov_string_print(&pinst->v_targetAddonlibsDir, "%s%s%c%s%c",
  // itemsVals[ACPLTHOME].var_current_props.value.valueunion.val_string,
  //"system", sep, "addonlibs", sep);;
  /* CTree_LoadLibs_execute(pinst); */
  return;
}

OV_DLLFNCEXPORT void CTree_LoadLibs_typemethod(OV_INSTPTR_fb_functionblock pfb,
                                               OV_TIME* pltc) {
  /*
   *   local variables
   */
  OV_INSTPTR_CTree_LoadLibs pinst = Ov_StaticPtrCast(CTree_LoadLibs, pfb);
  OV_RESULT                 result = OV_ERR_OK;
  OV_STRING_VEC             libsToSend = {0};
  /* OV_BYTE_VEC               blibs = {0, NULL}; */

  OV_INSTPTR_ksbase_ClientBase pClient =
      Ov_StaticPtrCast(ksbase_ClientBase, &pinst->p_ks);
  OV_VTBLPTR_ksbase_ClientBase pVtblClient = NULL;

  /*for local info*/
  OV_GETVAR_PAR gvParam = {0};
  OV_GETVAR_RES gvResult = {0};
  OV_TICKET*    pticket = NULL;

  switch(pinst->v_status) {
    case CTREE_LL_DONE:
    case CTREE_LL_INIT:
      /*
       * 1. get own os and arch
       */

      ov_memstack_lock();
      pticket = ksbase_NoneAuth->v_ticket.vtbl->createticket(NULL, OV_TT_NONE);
      gvParam.identifiers_len = 2;
      OV_STRING paths[2] = {
          "/data/CTree/dbinfo.serversystem",
          "/data/CTree/dbinfo.serversystemarch",
      };
      gvParam.identifiers_val = paths;

      ov_ksserver_getvar(2, pticket, &gvParam, &gvResult);

      Ov_WarnIf(gvResult.result);
      Ov_WarnIf(gvResult.items_val[0].result);
      Ov_WarnIf(gvResult.items_val[1].result);

      ov_string_setvalue(
          &pinst->v_OS,
          gvResult.items_val[OS].var_current_props.value.valueunion.val_string);
      pinst->v_Arch =
          gvResult.items_val[ARCH].var_current_props.value.valueunion.val_uint;

      /*
       * 2. get target info os and architect and libs
       */
      /* preparing client */
      OV_STRING serverHost = NULL;
      OV_STRING serverPort = NULL;
      OV_STRING serverName = NULL;
      OV_STRING serverNamePort = NULL;
      OV_STRING targetPath = NULL;
      ks_splitOneStringPath(pinst->v_targetKS, &serverHost, &serverPort,
                            &serverName, &serverNamePort, &targetPath);
      if(!serverHost || !serverName) {
        ov_logfile_error("%s: no serverHost||serverName set. aborting",
                         pinst->p_ks.v_identifier);
        pinst->v_result = OV_ERR_BADPARAM;
        pinst->v_status = CTREE_COMMON_INTERNALERROR;
        ov_memstack_unlock();
        return;
      }

      result |= ksbase_ClientBase_serverHost_set(
          (OV_INSTPTR_ksbase_ClientBase)&pinst->p_ks, serverHost);
      result |= ksbase_ClientBase_serverName_set(
          (OV_INSTPTR_ksbase_ClientBase)&pinst->p_ks, serverName);
      if(Ov_Fail(result)) {
        ov_logfile_error(
            "%s: submit: could not set hostName||serverName at Client",
            pinst->p_ks.v_identifier);
        pinst->v_result = result;
        pinst->v_status = CTREE_COMMON_INTERNALERROR;
        ov_memstack_unlock();
        return;
      }

      Ov_GetVTablePtr(ksbase_ClientBase, pVtblClient, pClient);
      if(!pVtblClient) {
        //			ov_logfile_error(
        //					"%s callback: could not
        // determine Vtable of Client %s. aborting",
        // pinst->v_identifier, that->v_identifier);
        pinst->v_status = CTREE_COMMON_INTERNALERROR;
        pinst->v_result = OV_ERR_BADOBJTYPE;
        ov_memstack_unlock();
        return;
      }
      OV_STRING targetpaths[FORMATLEN] = {
          [OS] = "/data/CTree/dbinfo.serversystem",
          [ARCH] = "/data/CTree/dbinfo.serversystemarch",
          [LIBS] = "/data/CTree/dbinfo.addonlibs"};

      result = pVtblClient->m_requestGetVar(
          pClient, NULL, FORMATLEN, targetpaths, (OV_INSTPTR_ov_domain)pinst,
          &infoRequest_callback);
      pinst->v_status = CTREE_LL_INFOREQSTED;

      if((pClient->v_state & KSBASE_CLST_ERROR)) {
        pinst->v_status = CTREE_COMMON_INTERNALERROR;
        ov_logfile_error("CTree_LoadLibs: ks error");
      }
      ov_memstack_unlock();
      break;
    case CTREE_LL_INFOREQSTED:
      break;
    case CTREE_LL_INFO_RECEIVED:

      /*
       * 3. compare os and arch
       */
      if(pinst->v_Arch == pinst->v_targetArch ||
         ov_string_compare(pinst->v_OS, pinst->v_targetOS) == OV_STRCMP_EQUAL) {
        ov_logfile_info("OS and Arch are matching with target system");
      } else {
        ov_logfile_error("Target os or arch is different from local");
        pinst->v_result = OV_ERR_BADVALUE;
        pinst->v_status = CTREE_COMMON_EXTERNALERROR;
        return;
      }
      /*
       * 4. Find out libs to transport
       */
      ov_memstack_lock();

      ov_logfile_info("%u", pinst->v_libsToSend.veclen);
      Ov_SetDynamicVectorLength(&libsToSend, pinst->v_libsToSend.veclen,
                                STRING);
      OV_UINT j = 0;
      for(OV_UINT i = 0; i < pinst->v_libsToSend.veclen; i++) {
        if(ov_strvec_contains(&pinst->v_targetLibs,
                              pinst->v_libsToSend.value[i])) {
          ov_logfile_info("Library %s exists", pinst->v_libsToSend.value[i]);
          libsToSend.veclen--;
        } else {
          ov_logfile_info("Library %s will be sent",
                          pinst->v_libsToSend.value[i]);
          ov_string_setvalue(&libsToSend.value[j],
                             pinst->v_libsToSend.value[i]);
          j++;
        }
      }
      /*
       * 5. convert libs to OV_BYTE_VEC
       */
      Ov_SetDynamicVectorLength(&pinst->p_sendFiles.v_filesToSend,
                                libsToSend.veclen, STRING);
      for(OV_UINT i = 0; i < libsToSend.veclen; ++i) {
        ov_string_print(&pinst->p_sendFiles.v_filesToSend.value[i],
                        "%s/system/addonlibs/%s%s", PACPLTHOME,
                        libsToSend.value[i], LIBEXTENSION);
        ov_logfile_info(pinst->p_sendFiles.v_filesToSend.value[i]);
      }
      Ov_SetDynamicVectorLength(&pinst->p_sendFiles.v_whereToSend,
                                libsToSend.veclen, STRING);
      for(OV_UINT i = 0; i < libsToSend.veclen; ++i) {
        ov_string_print(&pinst->p_sendFiles.v_whereToSend.value[i],
                        "%s/system/addonlibs/%s%s", PACPLTHOME,
                        libsToSend.value[i], LIBEXTENSION);
      }
      /*
       * 6. send libs
       */
      ov_string_setvalue(&pinst->p_sendFiles.v_targetKS, pinst->v_targetKS);
      /* triggering sendfiles */
      pinst->p_sendFiles.v_trigger = 0;
      result = CTree_Common_trigger_set(
          Ov_StaticPtrCast(CTree_Common, &pinst->p_sendFiles), 1);
      if(Ov_OK(result))
        pinst->v_status = CTREE_LL_DATA_SENT;
      else {
        ov_logfile_error("CTree_LoadLibs: Failed to trigger Sendfiles");
        pinst->v_result = OV_ERR_GENERIC;
        pinst->v_status = CTREE_COMMON_INTERNALERROR;
        ov_memstack_unlock();
        return;
      }
      ov_memstack_unlock();
      /* Ov_HeapFree(paddonlibs); */
      /* Ov_HeapFree(blibs.value); */
      break;
    case CTREE_LL_DATA_SENT:
      switch(pinst->p_sendFiles.v_status) {
        case CTREE_SF_DONE:
          ov_logfile_info("CTree_LoadLibs: Done.");
          pinst->v_status = CTREE_LL_DONE;
          pinst->v_actimode = 0;
          break;
        case CTREE_COMMON_INTERNALERROR:
        case CTREE_COMMON_EXTERNALERROR:
          pinst->v_status = pinst->p_sendFiles.v_status;
          pinst->v_result = pinst->p_sendFiles.v_result;
        default:
          pinst->v_status = CTREE_COMMON_INTERNALERROR;
          pinst->v_result = OV_ERR_GENERIC;
          break;
      }
      break;
    case CTREE_COMMON_INTERNALERROR:
    case CTREE_COMMON_EXTERNALERROR:
      pinst->v_actimode = 0;
      break;
    default:
      ov_logfile_error("%u : unexpected State", pinst->v_status);
      pinst->v_actimode = 0;
  }
  return;
}
