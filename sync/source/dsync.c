/******************************************************************************
 *
 *   FILE
 *   ----
 *   dsync.c
 *
 *   History
 *   -------
 *   2018-08-02   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/

#ifndef OV_COMPILE_LIBRARY_sync
#define OV_COMPILE_LIBRARY_sync
#endif

#include "CTree.h"
#include "PostSys.h"
#include "ksbase_helper.h"
#include "ksmsg.h"
#include "ksmsg_helper.h"
#include "libov/ov_macros.h"
#include "libov/ov_path.h"
#include "libov/ov_result.h"
#include "object_helper.h"
#include "sync.h"

#include "sync_helper.h"

#include "ksapi_commonFuncs.h"

#define SYNC_SRC_INIT 0
#define SYNC_SRC_SYNCCREATEREQUESTED 1
#define SYNC_SRC_TRANSPORTREQUESTED 2
#define SYNC_SRC_WAITINGFORSHUTDOWN 4
#define SYNC_SRC_DONE 8
#define SYNC_SRC_ERROR 64

OV_DLLFNCEXPORT OV_RESULT sync_dsync_constructor(OV_INSTPTR_ov_object pobj) {
  OV_RESULT             result = OV_ERR_OK;
  OV_INSTPTR_sync_dsync pinst = Ov_StaticPtrCast(sync_dsync, pobj);

  result = fb_functionblock_constructor(pobj);

  OV_ANY servername = {0};
  servername.value.vartype = OV_VT_VOID;
  servername.value.valueunion.val_string = NULL;
  result |= ov_vendortree_getservername(&servername, NULL);

  result |= ov_string_setvalue(&pinst->v_selfServer,
                               servername.value.valueunion.val_string);
  return result;
}

OV_DLLFNCEXPORT OV_RESULT sync_dsync_trigger_set(OV_INSTPTR_sync_dsync pinst,
                                                 const OV_BOOL         value) {
  if(value && !pinst->v_trigger && pinst->v_EN) {
    pinst->v_actimode = 1;
  }
  pinst->v_trigger = value;
  return 0;
}

OV_DLLFNCEXPORT OV_RESULT sync_dsync_reset_set(OV_INSTPTR_sync_dsync pobj,
                                               const OV_BOOL         value) {
  pobj->v_reset = value;
  if(value && !pobj->v_reset) {
    pobj->v_status = SYNC_SRC_INIT;
    ksapi_KSApiCommon_Reset_set(
        Ov_StaticPtrCast(ksapi_KSApiCommon, &pobj->p_kssetter), 0);
    ksapi_KSApiCommon_Reset_set(
        Ov_StaticPtrCast(ksapi_KSApiCommon, &pobj->p_kssetter), 1);
    ksapi_KSApiCommon_Reset_set(
        Ov_StaticPtrCast(ksapi_KSApiCommon, &pobj->p_ksCrtObj), 0);
    ksapi_KSApiCommon_Reset_set(
        Ov_StaticPtrCast(ksapi_KSApiCommon, &pobj->p_ksCrtObj), 1);
    CTree_Transport_reset_set(&pobj->p_transport, 0);
    CTree_Transport_reset_set(&pobj->p_transport, 1);
  }
  return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT sync_dsync_shutdown_set(OV_INSTPTR_sync_dsync pobj,
                                                  const OV_BOOL         value) {
  OV_RESULT result = OV_ERR_OK;
  pobj->v_reset = value;
  if(value) {
    /*check if request expected*/
    if(pobj->v_status != SYNC_SRC_WAITINGFORSHUTDOWN &&
       pobj->v_status != SYNC_SRC_TRANSPORTREQUESTED) {
      ov_logfile_error(
          "sync_dsync: shutdown requested, where no request expected");
      return OV_ERR_BADVALUE;
    }

    /*go on */
    OV_INSTPTR_ov_object proot = ov_path_getobjectpointer(pobj->v_srcPath, 2);
    if(!proot) {
      ov_logfile_error("root couldt be found %s", pobj->v_srcPath);
      pobj->v_status = DSYNC_DST_ERROR;
      pobj->v_result = OV_ERR_GENERIC;
      return OV_ERR_GENERIC;
    }
    const OV_STRING classesToConfiugure[] = {[KSAPISET] = "ksapi/setVar",
                                             [KSAPIGET] = "ksapi/getVar"};
    // shuttinmg dowmn
    for(OV_UINT i = 0; i < SYNC_CONFIGURE_LEN; ++i) {
      if(i != KSAPISET && i != KSAPIGET) {
        ov_logfile_warning("sync_dsync: cant handle %d", i);
        continue;
      }
      OV_INSTPTR_ov_class pssc = ov_class_search(classesToConfiugure[i]);
      if(pssc) {
        OV_INSTPTR_ov_object pobj = NULL;
        Ov_ForEachChild(ov_instantiation, pssc, pobj) {
          /* checking if right one */
          if(object_isDescendant(proot, Ov_StaticPtrCast(ov_object, pobj))) {
            OV_INSTPTR_ksmsg_msgClient pMsgClnt = Ov_SearchChildEx(
                ov_containment, Ov_StaticPtrCast(ov_domain, pobj), "msgClient",
                ksmsg_msgClient);
            if(!pMsgClnt) {
              ov_logfile_warning("%s has no msgClient", pobj->v_identifier);
              continue;
            }
            Ov_WarnIf(pMsgClnt->v_pathLen != 3);
            result = ksmsg_msgClient_path_deleteElement(pMsgClnt, 1);
            if(Ov_Fail(result)) {
              ov_logfile_error("%u: %s: failed to delete path element", result,
                               ov_result_getresulttext(result));
              return result;
            }
            if(i == KSAPISET) {
              // TODO: zzz: make sure it doesnt work again :2018 Dez 20
              // 11:56
              OV_INSTPTR_fbcomlib_setVar pfbsetVar = Ov_StaticPtrCast(
                  fbcomlib_setVar,
                  Ov_StaticPtrCast(ksapi_setVar, pobj)->v_pouterobject);
              if(pfbsetVar) {
                pfbsetVar->v_actimode = 0;
              }
              ov_logfile_info("%s.actimode = 0", pMsgClnt->v_identifier);
            }
          };
        }
      }
    }
  }
  pobj->v_status = SYNC_SRC_DONE;
  ov_logfile_info("dsync shutdown on src site.");
  return OV_ERR_OK;
}

OV_INSTPTR_ksmsg_msgClient dsync_createKsxdrAlt(OV_INSTPTR_sync_dsync pinst,
                                                OV_INSTPTR_ov_object  pobj) {
  OV_RESULT                  result = OV_ERR_OK;
  OV_INSTPTR_ksmsg_msgClient pMsgClnt = NULL;
  OV_STRING                  dstHost = NULL;
  OV_STRING                  dstServer = NULL;
  OV_STRING                  dstInst = NULL;
  OV_STRING                  dstHostPort = NULL;
  OV_STRING                  dstServerPort = NULL;

  /* Getting Servername  */
  OV_ANY servername = {0};
  servername.value.vartype = OV_VT_VOID;
  servername.value.valueunion.val_string = NULL;
  ov_vendortree_getservername(&servername, NULL);

  OV_INSTPTR_ksbase_ClientBase pClient = NULL;

  result = ks_splitOneStringPath(pinst->v_destKS, &dstHost, &dstHostPort,
                                 &dstServer, &dstServerPort, &dstInst);
  if(Ov_Fail(result)) {
    ov_logfile_error("%u: %s:", result, ov_result_getresulttext(result));
    return NULL;
  }

  /* if(Ov_CanCastTo(ksapi_setVar, pobj)) { */
  OV_INSTPTR_ksapi_KSApiCommon pobjCasted =
      Ov_StaticPtrCast(ksapi_KSApiCommon, pobj);

  Ov_ForEachChildEx(ov_containment, pobjCasted, pClient, ksbase_ClientBase) {
    /*	find the object in the containment which is
          derived from ClientBase	*/
    break;
  }
  if(Ov_CanCastTo(ksmsg_msgClient, pClient)) {
    pMsgClnt = Ov_StaticPtrCast(ksmsg_msgClient, pClient);
  } else {
    Ov_Unlink(ov_containment, pobjCasted, pClient);
    result =
        Ov_CreateObject(ksmsg_msgClient, pMsgClnt, pobjCasted, "msgClient");
    if(result) {
      // TODO: zzz: give more info Mo 10 Dez 2018 15:51:15 CET
      ov_logfile_info("%s couldnt create msgClient",
                      ov_result_getresulttext(result));
      return NULL;
    }
    Ov_Link(ov_containment, pobjCasted, pClient);
  }
  ksmsg_msgClient_pathLen_set(pMsgClnt, 3);

  ov_string_setvalue(&pMsgClnt->v_pathHost.value[0], pinst->v_selfHost);
  ov_string_setvalue(&pMsgClnt->v_pathName.value[0],
                     servername.value.valueunion.val_string);
  ov_string_setvalue(
      &pMsgClnt->v_pathInstance.value[0],
      ov_path_getcanonicalpath(Ov_StaticPtrCast(ov_object, pMsgClnt), 2));

  ov_string_setvalue(&pMsgClnt->v_pathHost.value[1], dstHost);
  ov_string_setvalue(&pMsgClnt->v_pathName.value[1], dstServer);
  ov_string_setvalue(&pMsgClnt->v_pathInstance.value[1],
                     PLAYER_SRCNODE_PATH_DEST);

  ov_string_setvalue(&pMsgClnt->v_pathHost.value[2], pobjCasted->v_serverHost);
  ov_string_setvalue(&pMsgClnt->v_pathName.value[2], pobjCasted->v_serverName);
  ov_string_setvalue(&pMsgClnt->v_pathInstance.value[2],
                     DEFAULT_POSTSYS_EXECUTER);
  // TODO: zzz: change status so that it can go on Mo 10 Dez 2018 16:31:06 CET
  return pMsgClnt;
}

OV_DLLFNCEXPORT void sync_dsync_typemethod(OV_INSTPTR_fb_functionblock pfb,
                                           OV_TIME*                    pltc) {
  /*
   *   local variables
   */
  OV_INSTPTR_sync_dsync pinst = Ov_StaticPtrCast(sync_dsync, pfb);

  OV_RESULT result = OV_ERR_OK;

  OV_STRING                  dsyncDstPath = "/data/dsyncDst";
  OV_STRING                  dstName = NULL;
  OV_STRING                  dstHost = NULL;
  OV_INSTPTR_CTree_Transport ptrans =
      Ov_StaticPtrCast(CTree_Transport, &pinst->p_transport);
  OV_INSTPTR_sync_dsyncDst pdsyncDst = &pinst->p_dsyncDstTemp;
  OV_INSTPTR_ov_object     proot = NULL;

  /* Getting Servername  */
  OV_ANY servername = {0};
  servername.value.vartype = OV_VT_VOID;
  servername.value.valueunion.val_string = NULL;
  ov_vendortree_getservername(&servername, NULL);

  ov_memstack_lock();
  switch(pinst->v_status) {
    case SYNC_SRC_INIT:
      if(!pinst->v_EN) {
        ov_logfile_warning("sync_dsync: not enabled");
        return;
      }
      /* check */
      proot = ov_path_getobjectpointer(pinst->v_srcPath, 2);
      if(!proot) {
        ov_logfile_error("root couldt be found");
        pinst->v_status = SYNC_SRC_ERROR;
        ov_memstack_unlock();
        return;
      } /* configure dest server */
      pinst->p_ksCrtObj.v_path = NULL;
      ks_splitOneStringPath(pinst->v_destKS, &dstHost, NULL, &dstName, NULL,
                            NULL);
      ov_string_print(&ptrans->v_targetKS, "//%s/%s%s", dstHost, dstName,
                      dsyncDstPath);

      OV_STRING srcKS = NULL;
      ov_string_print(&srcKS, "//%s/%s%s",
                      servername.value.valueunion.val_string,
                      pinst->v_selfServer, pinst->v_srcPath, 2);
      ov_string_setvalue(
          &pdsyncDst->v_syncPath,
          ov_path_getcanonicalpath(Ov_StaticPtrCast(ov_object, pinst), 2));
      result = sync_dsyncDst_srcKS_set(pdsyncDst, srcKS);
      result |= sync_dsyncDst_dstKS_set(pdsyncDst, pinst->v_destKS);
      if(Ov_Fail(result)) {
        ov_logfile_error("%u: %s: srcKS set failed", result,
                         ov_result_getresulttext(result));
        pinst->v_status = SYNC_SRC_ERROR;
        ov_memstack_unlock();
        return;
      }
      ov_string_setvalue(&srcKS, NULL);

      ov_string_setvalue(&pdsyncDst->p_syncDownload.v_srcPath,
                         pinst->v_srcPath);
      ov_string_setvalue(
          &ptrans->v_path,
          ov_path_getcanonicalpath(Ov_StaticPtrCast(ov_object, pdsyncDst), 2));
      pdsyncDst->v_actimode = 1;
      pdsyncDst->v_status = DSYNC_DST_ACTIVE;
      CTree_Transport_typemethod(Ov_StaticPtrCast(fb_functionblock, ptrans),
                                 NULL);
      pdsyncDst->v_actimode = 0;
      pinst->v_status = SYNC_SRC_SYNCCREATEREQUESTED;
      ov_logfile_info("sync on destination requested");
      ov_memstack_unlock();
      return;
      break;
    case SYNC_SRC_SYNCCREATEREQUESTED:
      /* if(pkscrt->v_status & KSAPI_COMMON_EXTERNALERROR & */
      /*    KSAPI_COMMON_INTERNALERROR) { */
      /*   pinst->v_status = SYNC_SRC_ERROR; */
      /*   ov_logfile_error("Error at ksapi"); */
      /*   pinst->v_result = OV_ERR_GENERIC; */
      /*   return; */
      /* } else if(pkscrt->v_status & KSAPI_COMMON_WAITINGFORANSWER) { */
      /*   return; */
      /* } else if(pkscrt->v_status & KSAPI_COMMON_REQUESTCOMPLETED) { */
      /* configure setvar & getvar */
      if(ptrans->v_status &
         (CTREE_COMMON_EXTERNALERROR | CTREE_COMMON_EXTERNALERROR)) {
        ov_logfile_error("sync_dsync: transport failed");
        pinst->v_status = SYNC_SRC_ERROR;
        ov_memstack_unlock();
        return;
      } else if(ptrans->v_status != CTREE_TRANSPORT_DONE) {
        ov_memstack_unlock();
        return;
      }
      result = ptrans->v_result;
      if(Ov_Fail(result)) {
        if(result != OV_ERR_ALREADYEXISTS) {
          ov_logfile_error("%u: %s: ksapi dsyncDst creation unsuccessful",
                           result, ov_result_getresulttext(result));
          pinst->v_result = result;
          ov_memstack_unlock();
          return;
        } else {
          ov_logfile_warning("%u: %s: dsyncDst", result,
                             ov_result_getresulttext(result));
        }
      }
      ov_logfile_info("dsyncDst created successfully. Transporting...");
      /* } */
      // setvar
      const OV_STRING classesToConfiugure[] = {[KSAPIGET] = "ksapi/getVar",
                                               [KSAPISET] = "ksapi/setVar"};

      proot = ov_path_getobjectpointer(pinst->v_srcPath, 2);
      if(!proot) {
        ov_logfile_error("sync_syncDownload: srcPath no proot");
        pinst->v_result = OV_ERR_GENERIC;
        ov_memstack_unlock();
        return;
      }
      for(OV_UINT i = 0; i < SYNC_CONFIGURE_LEN; ++i) {
        OV_INSTPTR_ov_class pssc = ov_class_search(classesToConfiugure[i]);
        if(pssc) {
          OV_INSTPTR_ov_object pobj = NULL;
          Ov_ForEachChild(ov_instantiation, pssc, pobj) {
            /* checking if right one */
            if(object_isDescendant(proot, Ov_StaticPtrCast(ov_object, pobj))) {
              /* create Msg alternative */
              OV_INSTPTR_ksmsg_msgClient pMsgClnt =
                  dsync_createKsxdrAlt(pinst, pobj);
              if(!pMsgClnt) {
                ov_logfile_error("sync_dsync: could not create Client %s",
                                 pobj->v_identifier);
                pinst->v_status = SYNC_SRC_ERROR;
                ov_memstack_unlock();
                return;
              }
            }
          }
        } else {
          ov_logfile_info("fbcomlib/setVar not used");
        }
      }
      ov_logfile_info("setgetalternate creation done.");

      /* run transport */
      OV_INSTPTR_CTree_Transport ptrans =
          Ov_StaticPtrCast(CTree_Transport, &pinst->p_transport);
      ov_string_setvalue(&ptrans->v_path, pinst->v_srcPath);
      ov_string_setvalue(&ptrans->v_targetKS, pinst->v_destKS);
      ov_string_print(&ptrans->v_targetDownloadPath, "%s%s", DSYNC_PATH_DEST,
                      DSYNC_DOWNLOAD_PATH_DEST_EXT);
      CTree_Transport_typemethod(Ov_StaticPtrCast(fb_functionblock, ptrans),
                                 NULL);

      pinst->v_status = SYNC_SRC_TRANSPORTREQUESTED;
      ov_logfile_info("transport requested");
      ov_memstack_unlock();
      return;
      break;
    case SYNC_SRC_TRANSPORTREQUESTED:
      if(pinst->p_transport.v_status == CTREE_TRANSPORT_DONE) {
        ov_logfile_info("transport done successfully");
        pinst->v_status = SYNC_SRC_WAITINGFORSHUTDOWN;
      } else {
        if(pinst->p_transport.v_status &
           (CTREE_COMMON_INTERNALERROR | CTREE_COMMON_EXTERNALERROR)) {
          ov_logfile_error("sync failed at transport");
          pinst->v_status = SYNC_SRC_ERROR;
        }
      }
      break;
    case SYNC_SRC_WAITINGFORSHUTDOWN:
      break;
    case SYNC_SRC_DONE:
      ov_logfile_info("sync in SYNC_SRC_DONE");
      pinst->v_actimode = 0;
      break;
    case SYNC_SRC_ERROR:
      pinst->v_actimode = 0;
      break;
    default:
      ov_logfile_error("sync_dsync: unknown status %d", pinst->v_status);
      ov_memstack_unlock();
      return;
  }
  /* wait for command */
  ov_memstack_unlock();
  return;
}
